本层的PDU为下层的SDU；本层的SDU为上层的PDU
SDU服务数据单元，对应于某个子层中没有被处理的数据。对于某个子层而言，进来的是SDU。
PDU协议数据单元，对应于被该子层处理形成特定格式的数据。对于某个子层而言，出去的就是PDU.
 所以说，在MAC层，RLC来的是SDU，PDU是封装后要交给物理层的。


ite-ue-main.cc 注释掉rece

2018.5.17  lte-ue-main.cc 的 phy_interface_mac类，在common头文件中已经被注释掉了

pdu_queue::pdu_queue.h 62行 std::vector<qbuff> pdu_q;    //PDU buffer
class qbuff 定义于qbuff.h

5.21  目前思路，在组包MUX的输出PDU存入PDU_queue,实现PDU_queue和DL_Harq的pid，在UE端做一个回复ACK的程序。
      common 46行 被注释掉了。
      mux.cc  203行uint8_t *ret = pdu_msg.write_packet(log_h);将PDU存入了buffer，涉及了srslte::sch_pdu pdu_msg;
      srslte::sch_pdu 定义于common的266行，该类的具体函数写在pdu.cc中

      namespace srslte {

class pdu_queue
{
public:
  class process_callback
  {
    public: 
      virtual void process_pdu(uint8_t *buff, uint32_t len) = 0;
  };  //这个纯虚函数是干啥的...
  5.22 修改了 pdu_queue.h 为:
  public: 
      //virtual void process_pdu(uint8_t *buff, uint32_t len) = 0;
      std::vector<bool> pro_callback(NOF_HARQ_PID,,false);     //自己加的用于ACK
  };

  修改了ite-udp

  修改了pdu_queue.cc和pdu_queue.h

  5.28
 探究为什么pdu_queue被初始化了2次
 注释掉了原程序中的pdu_queue 仍然发现pdu_queue初始化了，说明原程序已经调用了这个
 注释掉了main中的 mux初始化，仍然有pdu_queue初始化
   注释掉了demux初始化后，pdu_queue初始化信息消失，说明demux中使用到了pdu_queue
   demux.init()函数中包含了pdu.init(),其中pdu为srslte::pdu_queue pdus，所以此处调用了pdu_queue的init函数;

mux中的PDU缓冲结构为：    写在定义于pdu.h
     /* PDU Buffer */
  srslte::sch_pdu    pdu_msg; 
  bool msg3_has_been_transmitted;
  
   改动：在main中加了demux mac_demux_test_trans;来初始化一个pdu_queue
        目前看到了 q_buff的push



5.29 
qbuff::init   srslte_vec_malloc 中 这个if里调用了posix_memalign(&ptr,32,size)已经申请成功了，所以再return
qbuff::send 函数是真正的将数据存入的函数，其中还调用了qbuff::push函数